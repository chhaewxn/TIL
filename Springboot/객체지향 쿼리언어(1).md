# 📝 객체지향 쿼리언어
JPA가 지원하는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다. JPQL은 가장 중요한 객체지향 쿼리 언어이다. 

## 10.1 객체지향 쿼리 소개
### 10.1.1 JPQL 
엔티티 객체를 조회하는 객체지향 쿼리이다. SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL보다 코드가 간결하다.

### 10.1.2 Criteria 쿼리
JPQL을 생성하는 빌더 클래스이다. 장점은 문자가 아닌 프로그래밍 코드로 JPQL을 작성할 수 있다. 문자 기반 쿼리와 다르게 컴파일 시점에 오류를 발견할 수 있다.

하지만, 매우 복잡하기 때문에 사용하기 불편하고 코드도 한눈에 들어오지 않는다.

### 10.1.3 QueryDSL
JPQL을 생성하는 빌더 클래스이다. 코드 기반이면서 단순하고 사용하기 쉽다.

### 10.1.4 Native SQL
SQL을 직접 사용할 수 있는 기능이다. 특정 데이터베이스에 의존하는 기능을 사용해야할 때 이용한다. 데이터베이스를 변경하면 함께 수정해야한다는 단점이 있다.

## 10.2 JPQL
- 객체지향 쿼리 언어이다. 테이블을 대상으로 쿼리하는 것이 아니라, 엔티티 객체를 대상으로 쿼리한다.
- SQL을 추상화해서 특정 SQL에 의존하지 않는다.
- 결국 SQL로 변환된다.

### 10.2.1 기본 문법과 쿼리 API
SELECT, UPDATE, DELETE 문을 사용할 수 있고 em.persist() 메소드를 사용하면 되므로 INSERT 문은 없다.

**SELECT 문**
- 엔티티와 속성은 대소문자를 구분한다.
- 클래스 명이 아닌 엔티티 명을 사용한다.
- 별칭을 필수로 사용해야 한다.

**TypeQuery, Query**
- JPQL을 실행하기 위한 쿼리 객체이다.
- TypeQuery : 반환할 타입을 명확하게 지정할 수 있을 때
- Query : 반환할 타입을 명확하게 지정할 수 없을 때

### 10.2.2 파라미터 바인딩
**🔻 이름 기준 파라미터**
- 파라미터를 이름으로 구분하는 방법이다.
- 이름 기준 파라미터 앞에 :를 사용한다.

**🔻 위치 기준 파라미터**
- ? 다음에 위치 값을 준다.
- 위치 값은 1부터 시작한다.
- 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확하다!

### 10.2.3 프로젝션
SELECT 절에 조회할 대상을 지정하는 것이다.
프로젝션 대상은 엔티티, 임베디드 타입, 스칼라 타입이 있다.

**🔻 엔티티 프로젝션**
원하는 객체를 바로 조회할 수 있다.
조회한 엔티티는 영속성 컨텍스트에서 관리된다.

**🔻 임베디드 타입 프로젝션**
임베디드 타입은 조회의 시작점이 될 수 없다.
임베디드 타입은 엔티티 타입이 아닌 값 타입이기 때문에 영속성 컨텍스트에서 관리되지 않는다.

**🔻 스칼라 타입 프로젝션**
숫자, 문자, 날짜와 같은 기본 데이터 타입들을 말한다.
중복 데이터를 제거하려면 DISTINCT를 사용한다.

### 10.2.4 페이징 API
JPA는 페이징을 다음 두 API로 추상화 했다.
- setFirstResult(int startPosition): 조회 시작 위치
- setMaxResults(int maxResult): 조회할 데이터 수

### 10.2.5 집합과 정렬
🔻 집합 함수
- COUNT : 결과 수를 구한. 반환 타입: LONG
- MAX, MIN : 최대, 최소 값을 구한다. 문자, 숫자, 날짜 등에 사용됨
- AVG : 평균값을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: Double
- SUM : 합을 구한다. 숫자타입만 사용할 수 있다. 

**➕ 집합 함수 사용 시 참고사항**
- NULL 값은 무시하므로 통계에 잡히지 않음
(DISTINCT가 정의되어 있어도 무시)
- 값이 없는 경우에 SUM, AVG, MAX, MIN 함수를 사용하면 NULL이 된다. 단, COUNT는 0이 됨
- DISTINCT를 집합 함수 안에 사용하여 중복 값 제거 후 집합 구할 수 있음
- DISTINCT를 COUNT에서 사용할 때 임베디드 타입 지원 x

**🔻 GROUP BY**
통계 데이터를 구할 때 특정 그룹끼리 묶어줌

**🔻 HAVING**
GROUP BY와 함께 사용
GROUP BY로 그룹화 한 통계 데이터를 기준으로 필터링

**🔻정렬(ORDER BY)**
결과 정렬시 사용


